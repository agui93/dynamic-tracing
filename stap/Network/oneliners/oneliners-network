# probes
>> stap -L 'socket.*'
>> stap -L 'tcp.*'
>> stap -L 'udp.*'
>> stap -L 'sctp.*'
>> stap -L 'arp.*'
>> stap -L 'icmp.*'
>> stap -L '*mib.*'
>> stap -L 'tcpmib.*'
>> stap -L 'ipmib.*'
>> stap -L 'linuxmib.*'

>> stap -L 'kernel.function("socket*")'
>> stap -L 'kernel.function("tcp*")'
>> stap -L 'kernel.function("udp*")'
>> stap -L 'kernel.function("arp*")'
>> stap -L 'kernel.function("icmp*")'
>> stap -L 'kernel.function("*mib*")'
>> stap -L 'kernel.function("arp_*")'

>> stap -L 'kernel.function("tcp_retransmit_skb")'
>> stap -L 'kernel.function("inet_csk_accept")'


>> stap -L 'kernel.function("netif_*")'
>> stap -L 'kernel.function("napi_*")'
>> stap -L 'kernel.function("net_*")'
>> stap -L 'kernel.function("dev_queue_*")'





# Trace tcp receive packets
stap -v -T 5 -e 'global pkts; probe tcp.receive { pkts[daddr] <<< 1 }'
stap -v -T 5 -e 'global pkts; probe tcp.receive { pkts[saddr, sport, daddr, dport] <<< 1 }'



# Print a trace of threads sending IP packets (UDP or TCP)
stap -v -T 10 -e '
    probe netfilter.ip.local_out {
        printf("%s[%d] sent packet to %s:%d\n", execname(), tid(), daddr, dport);
    }
'

stap -v -T 3 -e '
    global agg;
    probe kernel.{function("ip_*"), function("ipv4_*"), function("ipv6_*")}{
        agg[probefunc()] <<< 1
    }
    probe end {
       foreach(f in agg-){
            printf("%-36s %5d\n", f, @count(agg[f]));
       }
    }
'


stap -v -T 3 -e '
    probe kernel.function("ip_finish_output"){
        printf("probefunc is : %s\n", probefunc());
        print_backtrace();
        print_ubacktrace();
        printf("\n");
    }
'


stap -v -T 3 -e '
    probe kernel.function("ip_rcv_finish"){
        printf("probefunc is : %s\n", probefunc());
        print_backtrace();
        print_ubacktrace();
        printf("\n");
    }
'

# Trace tcp func called count
stap -v -T 3 -e '
    global agg;
    probe kernel.function("tcp_*"){
        agg[probefunc()] <<< 1
    }
    probe end {
       foreach(f in agg-){
            printf("%-36s %5d\n", f, @count(agg[f]));
       }
    }
'


# Trace stack : tcp_disconnect
stap -v -T 10 -e '
    probe kernel.function("tcp_disconnect"){
        printf("probefunc is : %s\n", probefunc());
        print_backtrace();
        print_ubacktrace();
        printf("\n");
    }
'

# Trace stack : tcp_connect
stap -v -T 10 -e '
    probe kernel.function("tcp_connect"){
        printf("probefunc is : %s\n", probefunc());
        print_backtrace();
        print_ubacktrace();
        printf("\n");
    }
'


# Dump tcp like1
stap -v -T 5 -e '
    probe tcp.receive {
        printf(" %15s %15s  %5d  %5d  U=%d  A=%d  P=%d  R=%d  S=%d  F=%d\n",
        saddr, daddr, sport, dport, urg, ack, psh, rst, syn, fin)
    }
'

# Dump tcp like2
stap -v -T 5 -e '
    probe tcp.receive {
        state = tcp_ts_get_info_state($skb)
        printf(" %15s:%-5d %15s:%-5d  U=%d  A=%d  P=%d  R=%d  S=%d  F=%d state=%s[%d]\n",
         saddr, sport, daddr, dport, urg, ack, psh, rst, syn, fin, tcp_sockstate_str(state), state)
    }
'

# Trace information for each new incoming TCP connection accepted by the computer
stap -v -T 10 -e '
    probe kernel.{function("tcp_accept"),function("inet_csk_accept")}.return? {
        sock = $return
        rto = tcp_get_info_rto(sock)
        saddr   = format_ipaddr(__ip_sock_saddr(sock), __ip_sock_family(sock))
        daddr   = format_ipaddr(__ip_sock_daddr(sock), __ip_sock_family(sock))
        sport   = __tcp_sock_sport(sock)
        dport   = __tcp_sock_dport(sock)
        state = tcp_ts_get_info_state(sock)
        printf("%s:%d => %s:%d %s %d(ms)\n", saddr, sport, daddr, dport, tcp_sockstate_str(state), rto/1000);
    }
'

# Trace tcp disconnection (problem because of network map)
stap -v -T 15 -e '
    probe tcp.disconnect {
        saddr   = format_ipaddr(__ip_sock_saddr($sk), __ip_sock_family($sk))
        daddr   = format_ipaddr(__ip_sock_daddr($sk), __ip_sock_family($sk))
        sport   = __tcp_sock_sport($sk)
        dport   = __tcp_sock_dport($sk)
        state = tcp_ts_get_info_state($sk)
        printf("%s:%d => %s:%d %s\n", saddr, sport, daddr, dport, tcp_sockstate_str(state));
    }
'


stap -v -T 5 -e '
    probe kernel.function("tcp_rcv_established") {
        saddr   = format_ipaddr(__ip_sock_saddr($sk), __ip_sock_family($sk))
        sport   = __tcp_sock_sport($sk)
        daddr   = format_ipaddr(__ip_sock_daddr($sk), __ip_sock_family($sk))
        dport   = __tcp_sock_dport($sk)
        state = tcp_ts_get_info_state($sk)
        printf("%16s:%-5d %16s:%5d %s\n", saddr, sport, daddr, dport, tcp_sockstate_str(state));
    }
'


# Trace serverâ€“received tcp packets, useful for further customizations.
stap -v -T 5 -e '
    global pkts;
    probe tcp.recvmsg {
        pkts[saddr, sport, daddr, dport] <<< 1;
    }
    probe end{
        foreach([saddr, sport, daddr, dport] in pkts-){
            printf("%16s:%-5d %16s:%5d %5d\n",
                saddr, sport, daddr, dport, @count(pkts[saddr, sport, daddr, dport]));
        }
    }
'


stap -v -T 3 -e '
    probe kernel.function("dev_hard_start_xmit") {
        printf("probefunc is : %s\n", probefunc());
        print_backtrace();
        print_ubacktrace();
        printf("\n");
    }
'

stap -L 'kernel.function("arp_*")'
stap -L 'kernel.function("neigh_*")'

stap -v -T 3 -e '
    probe kernel.function("arp_create") {
        printf("probefunc is : %s\n", probefunc());
        print_backtrace();
        print_ubacktrace();
        printf("\n");
    }
'
